<html>
<head>
<meta charset="utf-8"/>
<script src="jquery-3.7.1.min.js"></script>
<style>
body {
    font-family: Arial, sans-serif;
    font-size: 14px;
    margin: 0px;
}
textarea {
	width: 100%;
	height: calc(100% - 30px);
	font-size: 13pt;
}
   textarea::-webkit-resizer {
           display: none;
           }
#word_counter{
	height: 25px;
}
</style>
</head>


<body>
 <textarea data-gramm_editor="false" name="txtScript" id="word_count" spellcheck="false"></textarea>
 <div id="word_counter">
	 Total word count: <span id="display_count">0</span> words. 
 </div>

<script type="text/javascript">
  
 let IBResultVariable = "V_StudentResponse_Chat";
 
 function setState(state){	 
	 if(!!state?.content && !!document.getElementById("word_count")){
	 	document.getElementById("word_count").value = state.content;
		refreshWordCount();
	 }
 }
 
 function getState() {
	let txt = document.getElementById("word_count")?.value;
	return !!txt ? {content: txt} : {content: ''};
}
 
 $(document).ready(function() {
	
	var indexPath = getQueryVariable('indexPath');
	var userDefIdPath = getQueryVariable('userDefIdPath');
	var tracecount = 1;	

	var userDefId = getUserDefinedID(userDefIdPath);
	
	if (userDefId=="WRITING_A_EPFChat" || userDefId=="WRITING_B_EPFChat"){
		IBResultVariable = "V_StudentResponse_Chat";
	}
	else{
		IBResultVariable = "V_StudentResponse_Traditional";
	} 
	  
	//logging
	var tmp = {
							   
	  'userDefIdPath': userDefIdPath,
	  'traceMessage': {},
	  'traceCount': tracecount		
	}

	$("textarea#word_count").unbind("blur").blur(function(e){
		 let data = Object.assign({}, tmp); 
									   
		 data['traceCount'] = traceCount++;
		 data['traceMessage'] = JSON.stringify({"event": "textareaBlur", "content": e.target.value});
		 window.parent.postMessage(JSON.stringify(data), "*");
		 //console.log("blur", data);
	});

	$("textarea#word_count").unbind("focus").focus(function(e){
		 let data = Object.assign({}, tmp);
										
		 data['traceCount'] = traceCount++;
		 data['traceMessage'] = JSON.stringify({"event": "textareaFocus", "content": e.target.value});
		 window.parent.postMessage(JSON.stringify(data), "*"); 
		 //console.log("focus", data);
	});

	$("textarea#word_count").unbind("scroll").scroll(function(e){
		 let data = Object.assign({}, tmp);
										 
		 data['traceCount'] = traceCount++;
		 data['traceMessage'] = JSON.stringify({"event": "textareaScroll", "content": e.target.value, "scrollTop": e.target.scrollTop});
		 window.parent.postMessage(JSON.stringify(data), "*");
		 //console.log("scroll", data);
	});	
    
	$("textarea#word_count").unbind("keydown").keydown(function(e){

	});
	


	var currentPasteEvent = {};

	//word counter
		$("#word_count").on('keydown', function(e) {

			var textarea = e.target;
			var charLower = String.fromCharCode(e.which).toLowerCase();

			if((e.ctrlKey || e.metaKey) && charLower == "v"){
				currentPasteEvent = {"cursorPosStart": textarea.selectionStart};
			}
		});

		$("#word_count").on('keyup', function(e) {
		
			var textarea = e.target;
			var charLower = String.fromCharCode(e.which).toLowerCase();
			var charStr = String.fromCharCode(e.which);
			var selection = (e.target.value).substring(textarea.selectionStart,textarea.selectionEnd);
			let data = Object.assign({}, tmp);
											
			data['traceCount'] = traceCount++;
		 
	
			//console.log(e, e.keyCode, charLower);
			if((e.ctrlKey || e.metaKey) && charLower == "c"){
				data['traceMessage'] = JSON.stringify({"event": "textareaCopy", "content": e.target.value, "selected": selection});
				window.parent.postMessage(JSON.stringify(data), "*");
				// console.log('CTRL + C', selection, data);
			}
			else if((e.ctrlKey || e.metaKey) && charLower == "x"){
				data['traceMessage'] = JSON.stringify({"event": "textareaCut", "content": e.target.value, "selected": selection});
				window.parent.postMessage(JSON.stringify(data), "*");
				//console.log('CTRL +  X', data);
			}			
			else if((e.ctrlKey || e.metaKey) && charLower == "v"){
				data['traceMessage'] = JSON.stringify({...currentPasteEvent, "event": "textareaPaste", "content": e.target.value, "cursorPosEnd": textarea.selectionStart});
				currentPasteEvent = {};
				window.parent.postMessage(JSON.stringify(data), "*");
				// console.log('CTRL +  V', data);
			}
			else{			 
				data['traceMessage'] = JSON.stringify({"event": "textareaChange", "content": e.target.value, "key": charStr, "keycode":  e.keyCode});
				window.parent.postMessage(JSON.stringify(data), "*");
				//console.log("keydown", data);
			}
			
			postSetVariable(IBResultVariable, this.value, traceCount++);
			
			refreshWordCount();
		});
	

 }); 

 
document.addEventListener('contextmenu', event => {
    event.preventDefault();
    console.log("Right Click");
});

function refreshWordCount(){
	let txtArea = $("#word_count");
	if (txtArea.length && txtArea[0].value.trim() != ""){	
		var words = txtArea[0].value.match(/\S+/g).length; 
		$('#display_count').text(words);
	}
}

function getSelectedText() {
    var text = "";
    if (typeof window.getSelection != "undefined") {
        text = window.getSelection().toString();
    } else if (typeof document.selection != "undefined" && document.selection.type == "Text") {
        text = document.selection.createRange().text;
    }
    return text;
}

function doSomethingWithSelectedText() {
    var selectedText = getSelectedText();
    if (selectedText) {
        console.log("Text selection: " + selectedText);
    }
}

document.onmouseup = doSomethingWithSelectedText;
document.onkeyup = doSomethingWithSelectedText; 

function getUserDefinedID(str) {
	if(!str)
		return '';
    var lastIndex = str.lastIndexOf('=');
    if (lastIndex === -1) {
        return ''; // Return an empty string if no "=" is found
    }
    return str.substring(lastIndex + 1); // +1 to start after the "="
}


/**
 * An example callback to process getVariable result messages.
 */
function acceptGetVariableResult(name, type, value, callId) {
	receivedFromRuntime = "Received variable info: " + name + "[" + type + "]=" + value + " (callId: " + callId + ")";
	updateDisplay();
}

/**
 * An example callback to process messages sent by the state machine operator callExternalPageFrame.
 */
function acceptOperatorMessage(data) {	
	receivedFromRuntime = data.join();
	console.log(data);
}

/**
 * An example callback to declare our variables.
 */
function declareVariables() {
	return [
		{ 
			name: 'StudentResponse',
	  		type: 'String',
	  		defaultValue: "",
	  	}
	];
}



// start listening to post message events and process them with our example callbacks
startListeningToRuntimePostMessageEvents(acceptGetVariableResult, acceptOperatorMessage);
startListeningToVariableDeclarationRequests(declareVariables);

// ------------------ methods for generic use ----------------------------------------------------------

let traceCount = 0;

/**
 * Trigger a state machine event in the CBA runtime. 
 * 
 * The traceCount parameter must be an integer value greater or equal 0 and
 * specifies wether the given the event will count as one or more user interactions.   
 */
 function postStatemachineEvent(eventName, traceCount)
{
	postMessageWithPaths({
        microfinEvent: eventName,
        traceCount: traceCount
	});
}

/**
 * Inject a message into the trace log of the CBA runtime. 
 * 
 * The traceType parameter is optional. It determines the trace type attribute 
 * of the injected trace message.
 * 
 * The traceCount parameter must be an integer value greater or equal 0 and
 * specifies wether the given the event will count as one or more user interactions.   
 */
 function postTraceMessage(traceMessage, traceType, traceCount)
{
	postMessageWithPaths({
    	traceMessage: traceMessage,
        traceType: traceType,
        traceCount: traceCount
	});
}

/**
 * Get the value of a variable in the CBA runtime. 
 * 
 * The callId parameter should be used to match the call to the 
 * result coming in via the getVariableResultCallback (see startListeningToPostMessageEvents method).
 */
 function postGetVariable(variableName, callId)
{
	postMessageWithPaths({
    	getVariable: {
    	  variableName: variableName,
    	  callId: callId,
    	},
        traceCount: 0

	});
}

/**
 * Set the value of a variable in the CBA runtime. 
 * 
 * The traceCount parameter must be an integer value greater or equal 0 and
 * specifies wether the given the event will count as one or more user interactions.   
 */
function postSetVariable(variableName, variableValue, traceCount)
{
	postMessageWithPaths({
    	setVariable: {
    	  variableName: variableName,
    	  newValue: variableValue,
    	},
    	type: 'String',
        traceCount: traceCount
	});
}

/**
 * Send the given payload as an event to the CBA runtime 
 * and implicitly extend it with the paths of our hosting ExternalPageFrame component.
 * 
 * This might might not work if the ExternalPageFrame content comes
 * from an external server. 
 * 
 */
function postMessageWithPaths(payload)
{
	payload.indexPath = getIndexPath();
	payload.userDefIdPath = getUserDefIdPath();
	postMessageWithErrorLog(payload);
}

/**
 * Send an event to the CBA runtime.
 */
function postMessageWithErrorLog(payload)
{
	try
	{
		// TODO: adapt the target origin  
		window.parent.postMessage(JSON.stringify(payload), '*');	
	} 
	catch(e) {
		console.debug(e); 
	}
}

/**
 * Obtain the path of user defined IDs leading to our hosting ExternalPageFrame component.
 * 
 * You might use this as value for the userDefIdPath attribute in the message payload structure
 * when sending events to the CBA runtime.
 * 
 * This might might not work if the ExternalPageFrame content comes
 * from an external server. 
 */
 function getUserDefIdPath()
{
	return getQueryVariable('userDefIdPath');
}

/**
 * Obtain the index path of our hosting ExternalPageFrame component.
 * 
 * You might use this as value for the userDefIdPath attribute in the message payload structure
 * when sending events to the CBA runtime.
 * 
 * This might might not work if the ExternalPageFrame content comes
 * from an external server. 
 */
function getIndexPath() 
{
	return getQueryVariable('indexPath');
}

/**
 * Obtain the value of a query variable from the calling URL. 
 * 
 * @variable: The name of the variable in the URL query.
 */
function getQueryVariable(variable)
{
	const parsedUrl = new URL(window.location.href);
	return parsedUrl.searchParams.get(variable);
}

/**
 * Start listening on post message events coming in from the CBA runtime.
 * 
 * The getVariableResultCallback parameter should be a method that accepts four parameters: 
 *   - name: the name of the variable
 *   - type: the data type of the variable
 *   - value: the value of the variable
 *   - callId: the callId of the getVariable call that triggered this result message.
 * 
 * The operatorMessageCallback parameter should be a method that accepts an array.
 * 
 */
 function startListeningToRuntimePostMessageEvents(getVariableResultCallback, operatorMessageCallback) {
    window.addEventListener(
	"message", 
	(event) => {
		const payload = JSON.parse(event.data);
		if (payload !== null && typeof(payload) === 'object' && payload.callId !== undefined) {
            if (payload.result !== null && typeof(payload.result) === 'object') {
			    const { name, type, value } = payload.result;			
			    getVariableResultCallback(name, type, value, payload.callId);
            }   
		} else if (Array.isArray(payload)) { 
			operatorMessageCallback(payload);
		}
	}, 
	false);
 }

 
/**
 * Start listening on post message events coming in from the item builder during time design time.
 * 
 * The declareVariableCallback parameter should be a method that expects no parameter and returns 
 * an array of variable declaration objects with these attributes:
 *   - name: the name of the variable
 *   - type: the type of the variable, one of 'Integer', 'Number', 'String', 'Boolean'
 *   - defaultValue: the initial value of the variable
 *   - namedValues: an array of objects with a name and a value attribute. 
 */
 function startListeningToVariableDeclarationRequests(declareVariableCallback) {
    // listener for providing initial variable data signal.
    window.addEventListener(
    "message",
    (event) => {    
        const { callId } = JSON.parse(event.data);
        if(callId !== undefined && callId.includes("importVariables")) {
            const variables = declareVariables();
            const pass_data = {
            initialVariables: variables,
            callId
            }
            try {
                window.parent.postMessage(JSON.stringify(pass_data), '*');
            } catch (error) {
                console.log("error on external listener - ", error);
            }
        }
    },
    false);
 }
 

  
</script>
</html>
